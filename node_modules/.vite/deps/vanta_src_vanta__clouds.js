import "./chunk-CSAU5B4Q.js";

// node_modules/vanta/src/helpers.js
Number.prototype.clamp = function(min, max) {
  return Math.min(Math.max(this, min), max);
};
function mobileCheck() {
  if (typeof navigator !== "undefined") {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 600;
  }
  return null;
}
var q = (sel) => document.querySelector(sel);
var color2Hex = (color) => {
  if (typeof color == "number") {
    return "#" + ("00000" + color.toString(16)).slice(-6);
  } else
    return color;
};
function clearThree(obj) {
  while (obj.children && obj.children.length > 0) {
    clearThree(obj.children[0]);
    obj.remove(obj.children[0]);
  }
  if (obj.geometry)
    obj.geometry.dispose();
  if (obj.material) {
    Object.keys(obj.material).forEach((prop) => {
      if (!obj.material[prop])
        return;
      if (obj.material[prop] !== null && typeof obj.material[prop].dispose === "function") {
        obj.material[prop].dispose();
      }
    });
    obj.material.dispose();
  }
}

// node_modules/vanta/src/_base.js
var win = typeof window == "object";
var THREE = win && window.THREE || {};
if (win && !window.VANTA)
  window.VANTA = {};
var VANTA = win && window.VANTA || {};
VANTA.register = (name, Effect2) => {
  return VANTA[name] = (opts) => new Effect2(opts);
};
VANTA.version = "0.5.24";
var error = function() {
  Array.prototype.unshift.call(arguments, "[VANTA]");
  return console.error.apply(this, arguments);
};
VANTA.VantaBase = class VantaBase {
  constructor(userOptions = {}) {
    if (!win)
      return false;
    VANTA.current = this;
    this.windowMouseMoveWrapper = this.windowMouseMoveWrapper.bind(this);
    this.windowTouchWrapper = this.windowTouchWrapper.bind(this);
    this.windowGyroWrapper = this.windowGyroWrapper.bind(this);
    this.resize = this.resize.bind(this);
    this.animationLoop = this.animationLoop.bind(this);
    this.restart = this.restart.bind(this);
    const defaultOptions = typeof this.getDefaultOptions === "function" ? this.getDefaultOptions() : this.defaultOptions;
    this.options = Object.assign({
      mouseControls: true,
      touchControls: true,
      gyroControls: false,
      minHeight: 200,
      minWidth: 200,
      scale: 1,
      scaleMobile: 1
    }, defaultOptions);
    if (userOptions instanceof HTMLElement || typeof userOptions === "string") {
      userOptions = { el: userOptions };
    }
    Object.assign(this.options, userOptions);
    if (this.options.THREE) {
      THREE = this.options.THREE;
    }
    this.el = this.options.el;
    if (this.el == null) {
      error('Instance needs "el" param!');
    } else if (!(this.options.el instanceof HTMLElement)) {
      const selector = this.el;
      this.el = q(selector);
      if (!this.el) {
        error("Cannot find element", selector);
        return;
      }
    }
    this.prepareEl();
    this.initThree();
    this.setSize();
    try {
      this.init();
    } catch (e) {
      error("Init error", e);
      if (this.renderer && this.renderer.domElement) {
        this.el.removeChild(this.renderer.domElement);
      }
      if (this.options.backgroundColor) {
        console.log("[VANTA] Falling back to backgroundColor");
        this.el.style.background = color2Hex(this.options.backgroundColor);
      }
      return;
    }
    this.initMouse();
    this.resize();
    this.animationLoop();
    const ad = window.addEventListener;
    ad("resize", this.resize);
    window.requestAnimationFrame(this.resize);
    if (this.options.mouseControls) {
      ad("scroll", this.windowMouseMoveWrapper);
      ad("mousemove", this.windowMouseMoveWrapper);
    }
    if (this.options.touchControls) {
      ad("touchstart", this.windowTouchWrapper);
      ad("touchmove", this.windowTouchWrapper);
    }
    if (this.options.gyroControls) {
      ad("deviceorientation", this.windowGyroWrapper);
    }
  }
  setOptions(userOptions = {}) {
    Object.assign(this.options, userOptions);
    this.triggerMouseMove();
  }
  prepareEl() {
    let i, child;
    if (typeof Node !== "undefined" && Node.TEXT_NODE) {
      for (i = 0; i < this.el.childNodes.length; i++) {
        const n = this.el.childNodes[i];
        if (n.nodeType === Node.TEXT_NODE) {
          const s = document.createElement("span");
          s.textContent = n.textContent;
          n.parentElement.insertBefore(s, n);
          n.remove();
        }
      }
    }
    for (i = 0; i < this.el.children.length; i++) {
      child = this.el.children[i];
      if (getComputedStyle(child).position === "static") {
        child.style.position = "relative";
      }
      if (getComputedStyle(child).zIndex === "auto") {
        child.style.zIndex = 1;
      }
    }
    if (getComputedStyle(this.el).position === "static") {
      this.el.style.position = "relative";
    }
  }
  applyCanvasStyles(canvasEl, opts = {}) {
    Object.assign(canvasEl.style, {
      position: "absolute",
      zIndex: 0,
      top: 0,
      left: 0,
      background: ""
    });
    Object.assign(canvasEl.style, opts);
    canvasEl.classList.add("vanta-canvas");
  }
  initThree() {
    if (!THREE.WebGLRenderer) {
      console.warn("[VANTA] No THREE defined on window");
      return;
    }
    this.renderer = new THREE.WebGLRenderer({
      alpha: true,
      antialias: true
    });
    this.el.appendChild(this.renderer.domElement);
    this.applyCanvasStyles(this.renderer.domElement);
    if (isNaN(this.options.backgroundAlpha)) {
      this.options.backgroundAlpha = 1;
    }
    this.scene = new THREE.Scene();
  }
  getCanvasElement() {
    if (this.renderer) {
      return this.renderer.domElement;
    }
    if (this.p5renderer) {
      return this.p5renderer.canvas;
    }
  }
  getCanvasRect() {
    const canvas = this.getCanvasElement();
    if (!canvas)
      return false;
    return canvas.getBoundingClientRect();
  }
  windowMouseMoveWrapper(e) {
    const rect = this.getCanvasRect();
    if (!rect)
      return false;
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (x >= 0 && y >= 0 && x <= rect.width && y <= rect.height) {
      this.mouseX = x;
      this.mouseY = y;
      if (!this.options.mouseEase)
        this.triggerMouseMove(x, y);
    }
  }
  windowTouchWrapper(e) {
    const rect = this.getCanvasRect();
    if (!rect)
      return false;
    if (e.touches.length === 1) {
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      if (x >= 0 && y >= 0 && x <= rect.width && y <= rect.height) {
        this.mouseX = x;
        this.mouseY = y;
        if (!this.options.mouseEase)
          this.triggerMouseMove(x, y);
      }
    }
  }
  windowGyroWrapper(e) {
    const rect = this.getCanvasRect();
    if (!rect)
      return false;
    const x = Math.round(e.alpha * 2) - rect.left;
    const y = Math.round(e.beta * 2) - rect.top;
    if (x >= 0 && y >= 0 && x <= rect.width && y <= rect.height) {
      this.mouseX = x;
      this.mouseY = y;
      if (!this.options.mouseEase)
        this.triggerMouseMove(x, y);
    }
  }
  triggerMouseMove(x, y) {
    if (x === void 0 && y === void 0) {
      if (this.options.mouseEase) {
        x = this.mouseEaseX;
        y = this.mouseEaseY;
      } else {
        x = this.mouseX;
        y = this.mouseY;
      }
    }
    if (this.uniforms) {
      this.uniforms.iMouse.value.x = x / this.scale;
      this.uniforms.iMouse.value.y = y / this.scale;
    }
    const xNorm = x / this.width;
    const yNorm = y / this.height;
    typeof this.onMouseMove === "function" ? this.onMouseMove(xNorm, yNorm) : void 0;
  }
  setSize() {
    this.scale || (this.scale = 1);
    if (mobileCheck() && this.options.scaleMobile) {
      this.scale = this.options.scaleMobile;
    } else if (this.options.scale) {
      this.scale = this.options.scale;
    }
    this.width = Math.max(this.el.offsetWidth, this.options.minWidth);
    this.height = Math.max(this.el.offsetHeight, this.options.minHeight);
  }
  initMouse() {
    if (!this.mouseX && !this.mouseY || this.mouseX === this.options.minWidth / 2 && this.mouseY === this.options.minHeight / 2) {
      this.mouseX = this.width / 2;
      this.mouseY = this.height / 2;
      this.triggerMouseMove(this.mouseX, this.mouseY);
    }
  }
  resize() {
    this.setSize();
    if (this.camera) {
      this.camera.aspect = this.width / this.height;
      if (typeof this.camera.updateProjectionMatrix === "function") {
        this.camera.updateProjectionMatrix();
      }
    }
    if (this.renderer) {
      this.renderer.setSize(this.width, this.height);
      this.renderer.setPixelRatio(window.devicePixelRatio / this.scale);
    }
    typeof this.onResize === "function" ? this.onResize() : void 0;
  }
  isOnScreen() {
    const elHeight = this.el.offsetHeight;
    const elRect = this.el.getBoundingClientRect();
    const scrollTop = window.pageYOffset || (document.documentElement || document.body.parentNode || document.body).scrollTop;
    const offsetTop = elRect.top + scrollTop;
    const minScrollTop = offsetTop - window.innerHeight;
    const maxScrollTop = offsetTop + elHeight;
    return minScrollTop <= scrollTop && scrollTop <= maxScrollTop;
  }
  animationLoop() {
    this.t || (this.t = 0);
    this.t2 || (this.t2 = 0);
    const now = performance.now();
    if (this.prevNow) {
      let elapsedTime = (now - this.prevNow) / (1e3 / 60);
      elapsedTime = Math.max(0.2, Math.min(elapsedTime, 5));
      this.t += elapsedTime;
      this.t2 += (this.options.speed || 1) * elapsedTime;
      if (this.uniforms) {
        this.uniforms.iTime.value = this.t2 * 0.016667;
      }
    }
    this.prevNow = now;
    if (this.options.mouseEase) {
      this.mouseEaseX = this.mouseEaseX || this.mouseX || 0;
      this.mouseEaseY = this.mouseEaseY || this.mouseY || 0;
      if (Math.abs(this.mouseEaseX - this.mouseX) + Math.abs(this.mouseEaseY - this.mouseY) > 0.1) {
        this.mouseEaseX += (this.mouseX - this.mouseEaseX) * 0.05;
        this.mouseEaseY += (this.mouseY - this.mouseEaseY) * 0.05;
        this.triggerMouseMove(this.mouseEaseX, this.mouseEaseY);
      }
    }
    if (this.isOnScreen() || this.options.forceAnimate) {
      if (typeof this.onUpdate === "function") {
        this.onUpdate();
      }
      if (this.scene && this.camera) {
        this.renderer.render(this.scene, this.camera);
        this.renderer.setClearColor(this.options.backgroundColor, this.options.backgroundAlpha);
      }
      if (this.fps && this.fps.update)
        this.fps.update();
      if (typeof this.afterRender === "function")
        this.afterRender();
    }
    return this.req = window.requestAnimationFrame(this.animationLoop);
  }
  // setupControls() {
  //   if (DEBUGMODE && THREE.OrbitControls) {
  //     this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement)
  //     Object.assign(this.controls, ORBITCONTROLS)
  //     return this.scene.add(new THREE.AxisHelper(100))
  //   }
  // }
  restart() {
    if (this.scene) {
      while (this.scene.children.length) {
        this.scene.remove(this.scene.children[0]);
      }
    }
    if (typeof this.onRestart === "function") {
      this.onRestart();
    }
    this.init();
  }
  init() {
    if (typeof this.onInit === "function") {
      this.onInit();
    }
  }
  destroy() {
    if (typeof this.onDestroy === "function") {
      this.onDestroy();
    }
    const rm = window.removeEventListener;
    rm("touchstart", this.windowTouchWrapper);
    rm("touchmove", this.windowTouchWrapper);
    rm("scroll", this.windowMouseMoveWrapper);
    rm("mousemove", this.windowMouseMoveWrapper);
    rm("deviceorientation", this.windowGyroWrapper);
    rm("resize", this.resize);
    window.cancelAnimationFrame(this.req);
    const scene = this.scene;
    if (scene && scene.children) {
      clearThree(scene);
    }
    if (this.renderer) {
      if (this.renderer.domElement) {
        this.el.removeChild(this.renderer.domElement);
      }
      this.renderer = null;
      this.scene = null;
    }
    if (VANTA.current === this) {
      VANTA.current = null;
    }
  }
};
var base_default = VANTA.VantaBase;

// node_modules/vanta/src/_shaderBase.js
var win2 = typeof window == "object";
var THREE2 = win2 && window.THREE;
var ShaderBase = class extends base_default {
  constructor(userOptions) {
    THREE2 = userOptions.THREE || THREE2;
    THREE2.Color.prototype.toVector = function() {
      return new THREE2.Vector3(this.r, this.g, this.b);
    };
    super(userOptions);
    this.updateUniforms = this.updateUniforms.bind(this);
  }
  init() {
    this.mode = "shader";
    this.uniforms = {
      iTime: {
        type: "f",
        value: 1
      },
      iResolution: {
        type: "v2",
        value: new THREE2.Vector2(1, 1)
      },
      iDpr: {
        type: "f",
        value: window.devicePixelRatio || 1
      },
      iMouse: {
        type: "v2",
        value: new THREE2.Vector2(this.mouseX || 0, this.mouseY || 0)
      }
    };
    super.init();
    if (this.fragmentShader) {
      this.initBasicShader();
    }
  }
  setOptions(userOptions) {
    super.setOptions(userOptions);
    this.updateUniforms();
  }
  initBasicShader(fragmentShader = this.fragmentShader, vertexShader = this.vertexShader) {
    if (!vertexShader) {
      vertexShader = "uniform float uTime;\nuniform vec2 uResolution;\nvoid main() {\n  gl_Position = vec4( position, 1.0 );\n}";
    }
    this.updateUniforms();
    if (typeof this.valuesChanger === "function") {
      this.valuesChanger();
    }
    const material = new THREE2.ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader,
      fragmentShader
    });
    const texPath = this.options.texturePath;
    if (texPath) {
      this.uniforms.iTex = {
        type: "t",
        value: new THREE2.TextureLoader().load(texPath)
      };
    }
    const mesh = new THREE2.Mesh(new THREE2.PlaneGeometry(2, 2), material);
    this.scene.add(mesh);
    this.camera = new THREE2.Camera();
    this.camera.position.z = 1;
  }
  updateUniforms() {
    const newUniforms = {};
    let k, v;
    for (k in this.options) {
      v = this.options[k];
      if (k.toLowerCase().indexOf("color") !== -1) {
        newUniforms[k] = {
          type: "v3",
          value: new THREE2.Color(v).toVector()
        };
      } else if (typeof v === "number") {
        newUniforms[k] = {
          type: "f",
          value: v
        };
      }
    }
    return Object.assign(this.uniforms, newUniforms);
  }
  resize() {
    super.resize();
    this.uniforms.iResolution.value.x = this.width / this.scale;
    this.uniforms.iResolution.value.y = this.height / this.scale;
  }
};

// node_modules/vanta/src/vanta.clouds.js
var Effect = class extends ShaderBase {
};
var vanta_clouds_default = VANTA.register("CLOUDS", Effect);
Effect.prototype.defaultOptions = {
  backgroundColor: 16777215,
  skyColor: 6863063,
  // 0x99b5bf,
  cloudColor: 11387358,
  cloudShadowColor: 1586512,
  sunColor: 16750873,
  // 0x1a9eaa
  sunGlareColor: 16737843,
  sunlightColor: 16750899,
  // 0x1a9eaa
  scale: 3,
  scaleMobile: 12,
  speed: 1,
  mouseEase: true
};
Effect.prototype.fragmentShader = `uniform vec2 iResolution;
uniform vec2 iMouse;
uniform float iTime;
uniform sampler2D iTex;

uniform float speed;
uniform vec3 skyColor;
uniform vec3 cloudColor;
uniform vec3 cloudShadowColor;
uniform vec3 sunColor;
uniform vec3 sunlightColor;
uniform vec3 sunGlareColor;
uniform vec3 backgroundColor;

// uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click
// uniform samplerXX iChannel0..3;          // input channel. XX = 2D/Cube


// Volumetric clouds. It performs level of detail (LOD) for faster rendering
float hash(float p) {
  p = fract(p * 0.011);
  p *= (p + 7.5);
  p *= (p + p);
  return fract(p);
}

float noise( vec3 x ){
    // The noise function returns a value in the range -1.0f -> 1.0f
    vec3 p = floor(x);
    vec3 f = fract(x);
    f       = f*f*(3.0-2.0*f);
    float n = p.x + p.y*57.0 + 113.0*p.z;
    return mix(mix(mix( hash(n+0.0  ), hash(n+1.0  ),f.x),
                   mix( hash(n+57.0 ), hash(n+58.0 ),f.x),f.y),
               mix(mix( hash(n+113.0), hash(n+114.0),f.x),
                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
}

const float constantTime = 1000.;
float map5( in vec3 p ){
    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;
    vec3 q = p - speed1*(iTime + constantTime);
    float f;
    f  = 0.50000*noise( q ); q = q*2.02;
    f += 0.25000*noise( q ); q = q*2.03;
    f += 0.12500*noise( q ); q = q*2.01;
    f += 0.06250*noise( q ); q = q*2.02;
    f += 0.03125*noise( q );
    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );
}
float map4( in vec3 p ){
    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;
    vec3 q = p - speed1*(iTime + constantTime);
    float f;
    f  = 0.50000*noise( q ); q = q*2.02;
    f += 0.25000*noise( q ); q = q*2.03;
    f += 0.12500*noise( q ); q = q*2.01;
    f += 0.06250*noise( q );
    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );
}
float map3( in vec3 p ){
    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;
    vec3 q = p - speed1*(iTime + constantTime);
    float f;
    f  = 0.50000*noise( q ); q = q*2.02;
    f += 0.25000*noise( q ); q = q*2.03;
    f += 0.12500*noise( q );
    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );
}
float map2( in vec3 p ){
    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;
    vec3 q = p - speed1*(iTime + constantTime);
    float f;
    f  = 0.50000*noise( q ); q = q*2.02;
    f += 0.25000*noise( q );
    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );
}

vec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );

vec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t ){
    // lighting
    vec3 lin = cloudColor*1.4 + sunlightColor*dif;
    vec4 col = vec4( mix( vec3(1.0,0.95,0.8), cloudShadowColor, den ), den );
    col.xyz *= lin;
    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );
    // front to back blending
    col.a *= 0.4;
    col.rgb *= col.a;
    return sum + col*(1.0-sum.a);
}

#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif = clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.075,0.02*t); }

vec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px ){
    vec4 sum = vec4(0.0);

    float t = 0.0;

    MARCH(20,map5);
    MARCH(25,map4);
    MARCH(30,map3);
    MARCH(40,map2);

    return clamp( sum, 0.0, 1.0 );
}

mat3 setCamera( in vec3 ro, in vec3 ta, float cr ){
    vec3 cw = normalize(ta-ro);
    vec3 cp = vec3(sin(cr), cos(cr),0.0);
    vec3 cu = normalize( cross(cw,cp) );
    vec3 cv = normalize( cross(cu,cw) );
    return mat3( cu, cv, cw );
}

vec4 render( in vec3 ro, in vec3 rd, in ivec2 px ){
    // background sky
    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );
    vec3 col = skyColor - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;
    col += 0.2*sunColor*pow( sun, 8.0 );

    // clouds
    vec4 res = raymarch( ro, rd, col, px );
    col = col*(1.0-res.w) + res.xyz;

    // sun glare
    col += 0.2*sunGlareColor*pow( sun, 3.0 );

    return vec4( col, 1.0 );
}

void main(){
    vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/ iResolution.y;

    vec2 m = iMouse.xy/iResolution.xy;
    m.y = (1.0 - m.y) * 0.33 + 0.28; // camera height

    m.x *= 0.25;
    m.x += sin(iTime * 0.1 + 3.1415) * 0.25 + 0.25;

    // camera
    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x))); // origin
    vec3 ta = vec3(0.0, -1.0, 0.0);
    mat3 ca = setCamera( ro, ta, 0.0 );
    // ray
    vec3 rd = ca * normalize( vec3(p.xy,1.5));

    gl_FragColor = render( ro, rd, ivec2(gl_FragCoord-0.5) );
}
`;
export {
  vanta_clouds_default as default
};
//# sourceMappingURL=vanta_src_vanta__clouds.js.map
