{
  "version": 3,
  "sources": ["../../vanta/src/_shaderBase.js", "../../vanta/src/vanta.clouds.js"],
  "sourcesContent": ["import VantaBase from './_base.js'\r\nexport {VANTA} from './_base.js'\r\n\r\nconst win = typeof window == 'object'\r\nlet THREE = win && window.THREE\r\n\r\nexport default class ShaderBase extends VantaBase {\r\n  constructor(userOptions) {\r\n    THREE = userOptions.THREE || THREE\r\n    THREE.Color.prototype.toVector = function(){\r\n      return new THREE.Vector3(this.r, this.g, this.b)\r\n    }\r\n    super(userOptions)\r\n    this.updateUniforms = this.updateUniforms.bind(this)\r\n  }\r\n  init(){\r\n    this.mode = 'shader'\r\n    this.uniforms = {\r\n      iTime: {\r\n        type: \"f\",\r\n        value: 1.0\r\n      },\r\n      iResolution: {\r\n        type: \"v2\",\r\n        value: new THREE.Vector2(1, 1)\r\n      },\r\n      iDpr: {\r\n        type: \"f\",\r\n        value: window.devicePixelRatio || 1\r\n      },\r\n      iMouse: {\r\n        type: \"v2\",\r\n        value: new THREE.Vector2(this.mouseX || 0, this.mouseY || 0)\r\n      }\r\n    }\r\n    super.init()\r\n    if (this.fragmentShader) {\r\n      this.initBasicShader()\r\n    }\r\n  }\r\n  setOptions(userOptions){\r\n    super.setOptions(userOptions)\r\n    this.updateUniforms()\r\n  }\r\n  initBasicShader(fragmentShader = this.fragmentShader, vertexShader = this.vertexShader) {\r\n    if (!vertexShader) {\r\n      vertexShader = \"uniform float uTime;\\nuniform vec2 uResolution;\\nvoid main() {\\n  gl_Position = vec4( position, 1.0 );\\n}\"\r\n    }\r\n    this.updateUniforms()\r\n    if (typeof this.valuesChanger === \"function\") {\r\n      this.valuesChanger() // Some effects define this themselves\r\n    }\r\n    const material = new THREE.ShaderMaterial({\r\n      uniforms: this.uniforms,\r\n      vertexShader: vertexShader,\r\n      fragmentShader: fragmentShader\r\n    })\r\n    const texPath = this.options.texturePath\r\n    if (texPath) {\r\n      this.uniforms.iTex = {\r\n        type: \"t\",\r\n        value: new THREE.TextureLoader().load(texPath)\r\n      }\r\n    }\r\n    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material)\r\n    this.scene.add(mesh)\r\n    this.camera = new THREE.Camera()\r\n    this.camera.position.z = 1\r\n  }\r\n\r\n  updateUniforms() {\r\n    const newUniforms = {}\r\n    let k, v\r\n    for (k in this.options) {\r\n      v = this.options[k]\r\n      if (k.toLowerCase().indexOf('color') !== -1) {\r\n        newUniforms[k] = {\r\n          type: \"v3\",\r\n          value: new THREE.Color(v).toVector()\r\n        }\r\n      } else if (typeof v === 'number') {\r\n        newUniforms[k] = {\r\n          type: \"f\",\r\n          value: v\r\n        }\r\n      }\r\n    }\r\n    return Object.assign(this.uniforms, newUniforms)\r\n  }\r\n  resize(){\r\n    super.resize()\r\n    this.uniforms.iResolution.value.x = this.width / this.scale\r\n    this.uniforms.iResolution.value.y = this.height / this.scale\r\n  }\r\n}", "import ShaderBase, {VANTA} from './_shaderBase.js'\r\n\r\nclass Effect extends ShaderBase {}\r\nexport default VANTA.register('CLOUDS', Effect)\r\n\r\nEffect.prototype.defaultOptions = {\r\n  backgroundColor: 0xffffff,\r\n  skyColor: 0x68b8d7, // 0x99b5bf,\r\n  cloudColor: 0xadc1de,\r\n  cloudShadowColor: 0x183550,\r\n  sunColor: 0xff9919, // 0x1a9eaa\r\n  sunGlareColor: 0xff6633,\r\n  sunlightColor: 0xff9933, // 0x1a9eaa\r\n  scale: 3,\r\n  scaleMobile: 12,\r\n  speed: 1,\r\n  mouseEase: true,\r\n}\r\n\r\nEffect.prototype.fragmentShader = `\\\r\nuniform vec2 iResolution;\r\nuniform vec2 iMouse;\r\nuniform float iTime;\r\nuniform sampler2D iTex;\r\n\r\nuniform float speed;\r\nuniform vec3 skyColor;\r\nuniform vec3 cloudColor;\r\nuniform vec3 cloudShadowColor;\r\nuniform vec3 sunColor;\r\nuniform vec3 sunlightColor;\r\nuniform vec3 sunGlareColor;\r\nuniform vec3 backgroundColor;\r\n\r\n// uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\r\n// uniform samplerXX iChannel0..3;          // input channel. XX = 2D/Cube\r\n\r\n\r\n// Volumetric clouds. It performs level of detail (LOD) for faster rendering\r\nfloat hash(float p) {\r\n  p = fract(p * 0.011);\r\n  p *= (p + 7.5);\r\n  p *= (p + p);\r\n  return fract(p);\r\n}\r\n\r\nfloat noise( vec3 x ){\r\n    // The noise function returns a value in the range -1.0f -> 1.0f\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f       = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+0.0  ), hash(n+1.0  ),f.x),\r\n                   mix( hash(n+57.0 ), hash(n+58.0 ),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n\r\nconst float constantTime = 1000.;\r\nfloat map5( in vec3 p ){\r\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\r\n    vec3 q = p - speed1*(iTime + constantTime);\r\n    float f;\r\n    f  = 0.50000*noise( q ); q = q*2.02;\r\n    f += 0.25000*noise( q ); q = q*2.03;\r\n    f += 0.12500*noise( q ); q = q*2.01;\r\n    f += 0.06250*noise( q ); q = q*2.02;\r\n    f += 0.03125*noise( q );\r\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\r\n}\r\nfloat map4( in vec3 p ){\r\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\r\n    vec3 q = p - speed1*(iTime + constantTime);\r\n    float f;\r\n    f  = 0.50000*noise( q ); q = q*2.02;\r\n    f += 0.25000*noise( q ); q = q*2.03;\r\n    f += 0.12500*noise( q ); q = q*2.01;\r\n    f += 0.06250*noise( q );\r\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\r\n}\r\nfloat map3( in vec3 p ){\r\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\r\n    vec3 q = p - speed1*(iTime + constantTime);\r\n    float f;\r\n    f  = 0.50000*noise( q ); q = q*2.02;\r\n    f += 0.25000*noise( q ); q = q*2.03;\r\n    f += 0.12500*noise( q );\r\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\r\n}\r\nfloat map2( in vec3 p ){\r\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\r\n    vec3 q = p - speed1*(iTime + constantTime);\r\n    float f;\r\n    f  = 0.50000*noise( q ); q = q*2.02;\r\n    f += 0.25000*noise( q );\r\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\r\n}\r\n\r\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\r\n\r\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t ){\r\n    // lighting\r\n    vec3 lin = cloudColor*1.4 + sunlightColor*dif;\r\n    vec4 col = vec4( mix( vec3(1.0,0.95,0.8), cloudShadowColor, den ), den );\r\n    col.xyz *= lin;\r\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\r\n    // front to back blending\r\n    col.a *= 0.4;\r\n    col.rgb *= col.a;\r\n    return sum + col*(1.0-sum.a);\r\n}\r\n\r\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif = clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.075,0.02*t); }\r\n\r\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px ){\r\n    vec4 sum = vec4(0.0);\r\n\r\n    float t = 0.0;\r\n\r\n    MARCH(20,map5);\r\n    MARCH(25,map4);\r\n    MARCH(30,map3);\r\n    MARCH(40,map2);\r\n\r\n    return clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\r\n    vec3 cw = normalize(ta-ro);\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n    vec3 cu = normalize( cross(cw,cp) );\r\n    vec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px ){\r\n    // background sky\r\n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\r\n    vec3 col = skyColor - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\r\n    col += 0.2*sunColor*pow( sun, 8.0 );\r\n\r\n    // clouds\r\n    vec4 res = raymarch( ro, rd, col, px );\r\n    col = col*(1.0-res.w) + res.xyz;\r\n\r\n    // sun glare\r\n    col += 0.2*sunGlareColor*pow( sun, 3.0 );\r\n\r\n    return vec4( col, 1.0 );\r\n}\r\n\r\nvoid main(){\r\n    vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/ iResolution.y;\r\n\r\n    vec2 m = iMouse.xy/iResolution.xy;\r\n    m.y = (1.0 - m.y) * 0.33 + 0.28; // camera height\r\n\r\n    m.x *= 0.25;\r\n    m.x += sin(iTime * 0.1 + 3.1415) * 0.25 + 0.25;\r\n\r\n    // camera\r\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x))); // origin\r\n    vec3 ta = vec3(0.0, -1.0, 0.0);\r\n    mat3 ca = setCamera( ro, ta, 0.0 );\r\n    // ray\r\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\r\n\r\n    gl_FragColor = render( ro, rd, ivec2(gl_FragCoord-0.5) );\r\n}\r\n`\r\n"],
  "mappings": "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",
  "names": []
}
