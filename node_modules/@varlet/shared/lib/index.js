var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/is.ts
var isString = (val) => typeof val === "string";
var isBoolean = (val) => typeof val === "boolean";
var isNumber = (val) => typeof val === "number";
var isNumeric = (val) => isNumber(val) || isString(val) && /^[-+]?\d+$/.test(val);
var isPlainObject = (val) => Object.prototype.toString.call(val) === "[object Object]";
var isObject = (val) => typeof val === "object" && val !== null;
var isFunction = (val) => typeof val === "function";
var isArray = (val) => Array.isArray(val);
var isURL = (val) => {
  if (!val) {
    return false;
  }
  return /^(http)|(\.*\/)/.test(val);
};
var isEmpty = (val) => val === void 0 || val === null || val === "" || Array.isArray(val) && !val.length;
var isWindow = (val) => val === window;
var supportTouch = () => inBrowser() && "ontouchstart" in window;
var inBrowser = () => typeof window !== "undefined";
var { hasOwnProperty } = Object.prototype;
var hasOwn = (val, key) => hasOwnProperty.call(val, key);

// src/array.ts
var uniq = (arr) => [...new Set(arr)];
var normalizeToArray = (value) => isArray(value) ? value : [value];
var removeItem = (arr, item) => {
  if (arr.length) {
    const index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
};
var toggleItem = (arr, item) => {
  arr.includes(item) ? removeItem(arr, item) : arr.push(item);
  return arr;
};
var removeArrayBlank = (arr) => arr.filter((item) => item != null);
var find = (arr, callback, from = "start") => {
  let i = from === "start" ? 0 : arr.length - 1;
  while (arr.length > 0 && i >= 0 && i <= arr.length - 1) {
    const flag = callback(arr[i], i, arr);
    if (flag) {
      return [arr[i], i];
    }
    from === "start" ? i++ : i--;
  }
  return [null, -1];
};
var classes = (...classes2) => classes2.map((className) => {
  if (isArray(className)) {
    const [condition, truthy, falsy = null] = className;
    return condition ? truthy : falsy;
  }
  return className;
});

// src/elements.ts
var getGlobalThis = () => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (inBrowser()) {
    return window;
  }
  return typeof global !== "undefined" ? global : self;
};
var requestAnimationFrame = (fn) => {
  const globalThis2 = getGlobalThis();
  return globalThis2.requestAnimationFrame ? globalThis2.requestAnimationFrame(fn) : globalThis2.setTimeout(fn);
};
var cancelAnimationFrame = (handle) => {
  const globalThis2 = getGlobalThis();
  globalThis2.cancelAnimationFrame ? globalThis2.cancelAnimationFrame(handle) : globalThis2.clearTimeout(handle);
};
var raf = () => new Promise((resolve) => {
  requestAnimationFrame(resolve);
});
var doubleRaf = () => new Promise((resolve) => {
  requestAnimationFrame(() => {
    requestAnimationFrame(resolve);
  });
});
var getStyle = (element) => window.getComputedStyle(element);
var getRect = (element) => {
  if (isWindow(element)) {
    const width = element.innerWidth;
    const height = element.innerHeight;
    const rect = {
      x: 0,
      y: 0,
      top: 0,
      left: 0,
      right: width,
      bottom: height,
      width,
      height
    };
    return __spreadProps(__spreadValues({}, rect), {
      toJSON: () => rect
    });
  }
  return element.getBoundingClientRect();
};
var inViewport = (element) => {
  const { top, bottom, left, right } = getRect(element);
  const { width, height } = getRect(window);
  const xInViewport = left <= width && right >= 0;
  const yInViewport = top <= height && bottom >= 0;
  return xInViewport && yInViewport;
};
var toDataURL = (file) => new Promise((resolve) => {
  const fileReader = new FileReader();
  fileReader.onload = () => {
    resolve(fileReader.result);
  };
  fileReader.readAsDataURL(file);
});
var preventDefault = (event) => {
  if (event.cancelable === false) {
    return;
  }
  event.preventDefault();
};
var getScrollTop = (element) => {
  const top = "scrollTop" in element ? element.scrollTop : element.scrollY;
  return Math.max(top, 0);
};
var getScrollLeft = (element) => {
  const left = "scrollLeft" in element ? element.scrollLeft : element.scrollX;
  return Math.max(left, 0);
};

// src/function.ts
var debounce = (fn, delay = 0) => {
  let timer;
  return function(...args) {
    if (timer) {
      window.clearTimeout(timer);
    }
    timer = window.setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
};
var throttle = (fn, delay = 200) => {
  let timer;
  let start = 0;
  return function loop(...args) {
    const now = Date.now();
    const elapsed = now - start;
    if (!start) {
      start = now;
    }
    if (timer) {
      window.clearTimeout(timer);
    }
    if (elapsed >= delay) {
      fn.apply(this, args);
      start = now;
    } else {
      timer = window.setTimeout(() => {
        loop.apply(this, args);
      }, delay - elapsed);
    }
  };
};
function call(fn, ...args) {
  if (isArray(fn)) {
    return fn.map((f) => f(...args));
  }
  if (fn) {
    return fn(...args);
  }
}

// src/number.ts
var toNumber = (val) => {
  if (val == null)
    return 0;
  if (isString(val)) {
    val = parseFloat(val);
    val = Number.isNaN(val) ? 0 : val;
    return val;
  }
  if (isBoolean(val))
    return Number(val);
  return val;
};
var clamp = (num, min, max) => Math.min(max, Math.max(min, num));
var clampArrayRange = (index, arr) => clamp(index, 0, arr.length - 1);

// src/string.ts
var bigCamelize = (s) => camelize(s).replace(s.charAt(0), s.charAt(0).toUpperCase());
var camelize = (s) => s.replace(/-(\w)/g, (_, p) => p.toUpperCase());
var kebabCase = (s) => {
  const ret = s.replace(/([A-Z])/g, " $1").trim();
  return ret.split(" ").join("-").toLowerCase();
};
function createNamespaceFn(namespace) {
  return (name) => {
    const componentName = `${namespace}-${name}`;
    const createBEM = (suffix) => {
      if (!suffix) {
        return componentName;
      }
      if (suffix[0] === "$") {
        return suffix.replace("$", namespace);
      }
      return suffix.startsWith("--") ? `${componentName}${suffix}` : `${componentName}__${suffix}`;
    };
    return {
      name: bigCamelize(componentName),
      n: createBEM,
      classes
    };
  };
}
export {
  bigCamelize,
  call,
  camelize,
  cancelAnimationFrame,
  clamp,
  clampArrayRange,
  classes,
  createNamespaceFn,
  debounce,
  doubleRaf,
  find,
  getGlobalThis,
  getRect,
  getScrollLeft,
  getScrollTop,
  getStyle,
  hasOwn,
  inBrowser,
  inViewport,
  isArray,
  isBoolean,
  isEmpty,
  isFunction,
  isNumber,
  isNumeric,
  isObject,
  isPlainObject,
  isString,
  isURL,
  isWindow,
  kebabCase,
  normalizeToArray,
  preventDefault,
  raf,
  removeArrayBlank,
  removeItem,
  requestAnimationFrame,
  supportTouch,
  throttle,
  toDataURL,
  toNumber,
  toggleItem,
  uniq
};
