import VarCheckbox from "../checkbox/index.mjs";
import Ripple from "../ripple/index.mjs";
import Hover from "../hover/index.mjs";
import VarHoverOverlay, { useHoverOverlay } from "../hover-overlay/index.mjs";
import { defineComponent, computed, ref, watch } from "vue";
import { useSelect } from "./provide.mjs";
import { createNamespace } from "../utils/components.mjs";
import { props } from "./props.mjs";
const { name, n, classes } = createNamespace("option");
import { normalizeClass as _normalizeClass, normalizeStyle as _normalizeStyle, createElementVNode as _createElementVNode, resolveComponent as _resolveComponent, withModifiers as _withModifiers, openBlock as _openBlock, createBlock as _createBlock, createCommentVNode as _createCommentVNode, renderSlot as _renderSlot, toDisplayString as _toDisplayString, createVNode as _createVNode, resolveDirective as _resolveDirective, createElementBlock as _createElementBlock, withDirectives as _withDirectives } from "vue";
function __render__(_ctx, _cache) {
  const _component_var_checkbox = _resolveComponent("var-checkbox");
  const _component_var_hover_overlay = _resolveComponent("var-hover-overlay");
  const _directive_ripple = _resolveDirective("ripple");
  const _directive_hover = _resolveDirective("hover");
  return _withDirectives((_openBlock(), _createElementBlock(
    "div",
    {
      class: _normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box"), [_ctx.optionSelected, _ctx.n("--selected-color")], [_ctx.disabled, _ctx.n("--disabled")])),
      style: _normalizeStyle({
        color: _ctx.optionSelected ? _ctx.focusColor : void 0
      }),
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    },
    [
      _createElementVNode(
        "div",
        {
          class: _normalizeClass(_ctx.classes(_ctx.n("cover"), [_ctx.optionSelected, _ctx.n("--selected-background")])),
          style: _normalizeStyle({
            background: _ctx.optionSelected ? _ctx.focusColor : void 0
          })
        },
        null,
        6
        /* CLASS, STYLE */
      ),
      _ctx.multiple ? (_openBlock(), _createBlock(_component_var_checkbox, {
        key: 0,
        ref: "checkbox",
        modelValue: _ctx.optionSelected,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.optionSelected = $event),
        "checked-color": _ctx.focusColor,
        disabled: _ctx.disabled,
        onClick: _cache[1] || (_cache[1] = _withModifiers(() => {
        }, ["stop"])),
        onChange: _ctx.handleSelect
      }, null, 8, ["modelValue", "checked-color", "disabled", "onChange"])) : _createCommentVNode("v-if", true),
      _renderSlot(_ctx.$slots, "default", {}, () => [
        _createElementVNode(
          "div",
          {
            class: _normalizeClass(_ctx.classes(_ctx.n("text"), _ctx.n("$--ellipsis")))
          },
          _toDisplayString(_ctx.label),
          3
          /* TEXT, CLASS */
        )
      ]),
      _createVNode(_component_var_hover_overlay, {
        hovering: _ctx.hovering && !_ctx.disabled
      }, null, 8, ["hovering"])
    ],
    6
    /* CLASS, STYLE */
  )), [
    [_directive_ripple, { disabled: _ctx.disabled }],
    [_directive_hover, _ctx.handleHovering, "desktop"]
  ]);
}
const __sfc__ = defineComponent({
  name,
  directives: { Ripple, Hover },
  components: {
    VarCheckbox,
    VarHoverOverlay
  },
  props,
  setup(props2) {
    const optionSelected = ref(false);
    const selected = computed(() => optionSelected.value);
    const label = computed(() => props2.label);
    const value = computed(() => props2.value);
    const { select, bindSelect } = useSelect();
    const { multiple, focusColor, onSelect, computeLabel } = select;
    const { hovering, handleHovering } = useHoverOverlay();
    const optionProvider = {
      label,
      value,
      selected,
      sync
    };
    watch([() => props2.label, () => props2.value], computeLabel);
    bindSelect(optionProvider);
    function handleClick() {
      if (props2.disabled) {
        return;
      }
      handleSelect();
    }
    function handleSelect() {
      if (multiple.value) {
        optionSelected.value = !optionSelected.value;
      }
      onSelect(optionProvider);
    }
    function sync(checked) {
      optionSelected.value = checked;
    }
    return {
      optionSelected,
      multiple,
      focusColor,
      hovering,
      n,
      classes,
      handleHovering,
      handleClick,
      handleSelect
    };
  }
});
__sfc__.render = __render__;
var stdin_default = __sfc__;
export {
  stdin_default as default
};
