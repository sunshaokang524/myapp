import VarIcon from "../icon/index.mjs";
import VarFormDetails from "../form-details/index.mjs";
import Ripple from "../ripple/index.mjs";
import Hover from "../hover/index.mjs";
import VarHoverOverlay, { useHoverOverlay } from "../hover-overlay/index.mjs";
import { computed, defineComponent, nextTick, ref } from "vue";
import { props } from "./props.mjs";
import { useValidation, createNamespace } from "../utils/components.mjs";
import { useRadioGroup } from "./provide.mjs";
import { useForm } from "../form/provide.mjs";
import { call } from "@varlet/shared";
import { useVModel } from "@varlet/use";
const { name, n, classes } = createNamespace("radio");
import { renderSlot as _renderSlot, resolveComponent as _resolveComponent, normalizeClass as _normalizeClass, createVNode as _createVNode, normalizeStyle as _normalizeStyle, resolveDirective as _resolveDirective, openBlock as _openBlock, createElementBlock as _createElementBlock, withDirectives as _withDirectives, createElementVNode as _createElementVNode, mergeProps as _mergeProps } from "vue";
function __render__(_ctx, _cache) {
  const _component_var_icon = _resolveComponent("var-icon");
  const _component_var_hover_overlay = _resolveComponent("var-hover-overlay");
  const _component_var_form_details = _resolveComponent("var-form-details");
  const _directive_ripple = _resolveDirective("ripple");
  const _directive_hover = _resolveDirective("hover");
  return _openBlock(), _createElementBlock(
    "div",
    {
      class: _normalizeClass(_ctx.n("wrap"))
    },
    [
      _createElementVNode(
        "div",
        _mergeProps({
          class: _ctx.n(),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
        }, _ctx.$attrs),
        [
          _withDirectives((_openBlock(), _createElementBlock(
            "div",
            {
              class: _normalizeClass(
                _ctx.classes(
                  _ctx.n("action"),
                  [_ctx.checked, _ctx.n("--checked"), _ctx.n("--unchecked")],
                  [_ctx.errorMessage || _ctx.radioGroupErrorMessage, _ctx.n("--error")],
                  [_ctx.formDisabled || _ctx.disabled, _ctx.n("--disabled")]
                )
              ),
              style: _normalizeStyle({ color: _ctx.checked ? _ctx.checkedColor : _ctx.uncheckedColor })
            },
            [
              _ctx.checked ? _renderSlot(_ctx.$slots, "checked-icon", { key: 0 }, () => [
                _createVNode(_component_var_icon, {
                  class: _normalizeClass(_ctx.classes(_ctx.n("icon"), [_ctx.withAnimation, _ctx.n("--with-animation")])),
                  "var-radio-cover": "",
                  name: "radio-marked",
                  size: _ctx.iconSize
                }, null, 8, ["class", "size"])
              ]) : _renderSlot(_ctx.$slots, "unchecked-icon", { key: 1 }, () => [
                _createVNode(_component_var_icon, {
                  class: _normalizeClass(_ctx.classes(_ctx.n("icon"), [_ctx.withAnimation, _ctx.n("--with-animation")])),
                  "var-radio-cover": "",
                  name: "radio-blank",
                  size: _ctx.iconSize
                }, null, 8, ["class", "size"])
              ]),
              _createVNode(_component_var_hover_overlay, {
                hovering: !_ctx.disabled && !_ctx.formDisabled && _ctx.hovering
              }, null, 8, ["hovering"])
            ],
            6
            /* CLASS, STYLE */
          )), [
            [_directive_ripple, { disabled: _ctx.formReadonly || _ctx.readonly || _ctx.formDisabled || _ctx.disabled || !_ctx.ripple }],
            [_directive_hover, _ctx.handleHovering, "desktop"]
          ]),
          _createElementVNode(
            "div",
            {
              class: _normalizeClass(
                _ctx.classes(
                  _ctx.n("text"),
                  [_ctx.errorMessage || _ctx.radioGroupErrorMessage, _ctx.n("--error")],
                  [_ctx.formDisabled || _ctx.disabled, _ctx.n("--disabled")]
                )
              )
            },
            [
              _renderSlot(_ctx.$slots, "default")
            ],
            2
            /* CLASS */
          )
        ],
        16
        /* FULL_PROPS */
      ),
      _createVNode(_component_var_form_details, { "error-message": _ctx.errorMessage }, null, 8, ["error-message"])
    ],
    2
    /* CLASS */
  );
}
const __sfc__ = defineComponent({
  name,
  directives: { Ripple, Hover },
  components: {
    VarIcon,
    VarFormDetails,
    VarHoverOverlay
  },
  inheritAttrs: false,
  props,
  setup(props2) {
    const value = useVModel(props2, "modelValue");
    const checked = computed(() => value.value === props2.checkedValue);
    const withAnimation = ref(false);
    const { radioGroup, bindRadioGroup } = useRadioGroup();
    const { hovering, handleHovering } = useHoverOverlay();
    const { form, bindForm } = useForm();
    const {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = useValidation();
    const radioProvider = {
      sync,
      validate,
      resetValidation,
      reset
    };
    call(bindRadioGroup, radioProvider);
    call(bindForm, radioProvider);
    function validateWithTrigger(trigger) {
      nextTick(() => {
        const { validateTrigger, rules, modelValue } = props2;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    }
    function change(changedValue) {
      const { checkedValue, onChange } = props2;
      if (radioGroup && value.value === checkedValue) {
        return;
      }
      value.value = changedValue;
      call(onChange, value.value);
      radioGroup == null ? void 0 : radioGroup.onToggle(checkedValue);
      validateWithTrigger("onChange");
    }
    function handleClick(e) {
      const { disabled, readonly, uncheckedValue, checkedValue, onClick } = props2;
      if ((form == null ? void 0 : form.disabled.value) || disabled) {
        return;
      }
      call(onClick, e);
      if ((form == null ? void 0 : form.readonly.value) || readonly) {
        return;
      }
      withAnimation.value = true;
      change(checked.value ? uncheckedValue : checkedValue);
    }
    function sync(v2) {
      const { checkedValue, uncheckedValue } = props2;
      value.value = v2 === checkedValue ? checkedValue : uncheckedValue;
    }
    function reset() {
      value.value = props2.uncheckedValue;
      resetValidation();
    }
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    function toggle(changedValue) {
      const { uncheckedValue, checkedValue } = props2;
      const shouldReverse = ![uncheckedValue, checkedValue].includes(changedValue);
      if (shouldReverse) {
        changedValue = checked.value ? uncheckedValue : checkedValue;
      }
      change(changedValue);
    }
    return {
      withAnimation,
      checked,
      errorMessage,
      radioGroupErrorMessage: radioGroup == null ? void 0 : radioGroup.errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      hovering,
      handleHovering,
      n,
      classes,
      handleClick,
      toggle,
      reset,
      validate,
      resetValidation
    };
  }
});
__sfc__.render = __render__;
var stdin_default = __sfc__;
export {
  stdin_default as default
};
