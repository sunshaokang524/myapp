var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
import flip from "@popperjs/core/lib/modifiers/flip";
import offset from "@popperjs/core/lib/modifiers/offset";
import computeStyles from "@popperjs/core/lib/modifiers/computeStyles";
import { useClickOutside, useVModel } from "@varlet/use";
import { doubleRaf, getStyle, call } from "@varlet/shared";
import { toPxNum } from "../utils/elements.mjs";
import { onMounted, onUnmounted, ref, watch } from "vue";
import { createPopper } from "@popperjs/core/lib/popper-lite";
import { useZIndex } from "../context/zIndex.mjs";
function usePopover(options) {
  const host = ref(null);
  const popover = ref(null);
  const hostSize = ref({ width: 0, height: 0 });
  const show = useVModel(options, "show", {
    passive: true,
    defaultValue: false,
    emit(event, value) {
      if (value) {
        resize();
        call(options.onOpen);
      } else {
        call(options.onClose);
      }
    }
  });
  const { zIndex } = useZIndex(() => show.value, 1);
  let popoverInstance = null;
  let enterPopover = false;
  let enterHost = false;
  const computeHostSize = () => {
    const { width, height } = getStyle(host.value);
    hostSize.value = {
      width: toPxNum(width),
      height: toPxNum(height)
    };
  };
  const getTransformOrigin = () => {
    switch (options.placement) {
      case "top":
      case "cover-bottom":
        return "bottom";
      case "top-start":
      case "right-end":
      case "cover-bottom-start":
        return "bottom left";
      case "top-end":
      case "left-end":
      case "cover-bottom-end":
        return "bottom right";
      case "bottom":
      case "cover-top":
        return "top";
      case "bottom-start":
      case "right-start":
      case "cover-top-start":
        return "top left";
      case "bottom-end":
      case "left-start":
      case "cover-top-end":
        return "top right";
      case "left":
      case "cover-right":
        return "right";
      case "right":
      case "cover-left":
        return "left";
    }
  };
  const handleHostMouseenter = () => {
    if (options.trigger !== "hover") {
      return;
    }
    enterHost = true;
    open();
  };
  const handleHostMouseleave = () => __async(this, null, function* () {
    if (options.trigger !== "hover") {
      return;
    }
    enterHost = false;
    yield doubleRaf();
    if (enterPopover) {
      return;
    }
    close();
  });
  const handlePopoverMouseenter = () => {
    if (options.trigger !== "hover") {
      return;
    }
    enterPopover = true;
  };
  const handlePopoverMouseleave = () => __async(this, null, function* () {
    if (options.trigger !== "hover") {
      return;
    }
    enterPopover = false;
    yield doubleRaf();
    if (enterHost) {
      return;
    }
    close();
  });
  const handleHostClick = () => {
    if (options.closeOnClickReference && show.value) {
      close();
    } else {
      open();
    }
  };
  const handlePopoverClose = () => {
    close();
  };
  const handleClickOutside = (e) => {
    if (options.trigger !== "click") {
      return;
    }
    handlePopoverClose();
    call(options.onClickOutside, e);
  };
  const handleClosed = () => {
    resize();
    call(options.onClosed);
  };
  const getPosition = () => {
    const { offsetX, offsetY, placement } = options;
    computeHostSize();
    const offset2 = {
      x: toPxNum(offsetX),
      y: toPxNum(offsetY)
    };
    switch (placement) {
      case "cover-top":
        return {
          placement: "bottom",
          skidding: offset2.x,
          distance: offset2.y - hostSize.value.height
        };
      case "cover-top-start":
        return {
          placement: "bottom-start",
          skidding: offset2.x,
          distance: offset2.y - hostSize.value.height
        };
      case "cover-top-end":
        return {
          placement: "bottom-end",
          skidding: offset2.x,
          distance: offset2.y - hostSize.value.height
        };
      case "cover-bottom":
        return {
          placement: "top",
          skidding: offset2.x,
          distance: -offset2.y - hostSize.value.height
        };
      case "cover-bottom-start":
        return {
          placement: "top-start",
          skidding: offset2.x,
          distance: -offset2.y - hostSize.value.height
        };
      case "cover-bottom-end":
        return {
          placement: "top-end",
          skidding: offset2.x,
          distance: -offset2.y - hostSize.value.height
        };
      case "cover-left":
        return {
          placement: "right",
          skidding: offset2.y,
          distance: offset2.x - hostSize.value.width
        };
      case "cover-right":
        return {
          placement: "left",
          skidding: offset2.y,
          distance: -offset2.x - hostSize.value.width
        };
      case "left":
      case "left-start":
      case "left-end":
        return {
          placement,
          skidding: offset2.y,
          distance: -offset2.x
        };
      case "top":
      case "top-start":
      case "top-end":
        return {
          placement,
          skidding: offset2.x,
          distance: -offset2.y
        };
      case "bottom":
      case "bottom-start":
      case "bottom-end":
        return {
          placement,
          skidding: offset2.x,
          distance: offset2.y
        };
      case "right":
      case "right-start":
      case "right-end":
        return {
          placement,
          skidding: offset2.y,
          distance: offset2.x
        };
    }
  };
  const getPopperOptions = () => {
    const { placement, skidding, distance } = getPosition();
    const modifiers = [
      __spreadProps(__spreadValues({}, flip), {
        enabled: show.value
      }),
      __spreadProps(__spreadValues({}, offset), {
        options: {
          offset: [skidding, distance]
        }
      }),
      __spreadProps(__spreadValues({}, computeStyles), {
        options: {
          adaptive: false,
          gpuAcceleration: false
        },
        enabled: show.value
      }),
      {
        name: "applyTransformOrigin",
        enabled: show.value,
        phase: "beforeWrite",
        fn({ state }) {
          state.styles.popper.transformOrigin = getTransformOrigin();
        }
      }
    ];
    return {
      placement,
      modifiers,
      strategy: options.strategy
    };
  };
  const getReference = () => options.reference ? host.value.querySelector(options.reference) : host.value;
  const resize = () => {
    popoverInstance.setOptions(getPopperOptions());
  };
  const open = () => {
    const { disabled } = options;
    if (disabled) {
      return;
    }
    show.value = true;
    call(options["onUpdate:show"], true);
  };
  const close = () => {
    show.value = false;
    call(options["onUpdate:show"], false);
  };
  useClickOutside(getReference, "click", handleClickOutside);
  watch(() => [options.offsetX, options.offsetY, options.placement, options.strategy], resize);
  watch(() => options.disabled, close);
  onMounted(() => {
    var _a;
    popoverInstance = createPopper((_a = getReference()) != null ? _a : host.value, popover.value, getPopperOptions());
  });
  onUnmounted(() => {
    popoverInstance.destroy();
  });
  return {
    show,
    popover,
    zIndex,
    host,
    hostSize,
    handleHostClick,
    handleHostMouseenter,
    handleHostMouseleave,
    handlePopoverClose,
    handlePopoverMouseenter,
    handlePopoverMouseleave,
    handleClosed,
    resize,
    open,
    close
  };
}
export {
  usePopover
};
