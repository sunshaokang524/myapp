import Ripple from "../ripple/index.mjs";
import VarLoading from "../loading/index.mjs";
import VarHoverOverlay, { useHoverOverlay } from "../hover-overlay/index.mjs";
import Hover from "../hover/index.mjs";
import { computed, defineComponent, ref } from "vue";
import { props } from "./props.mjs";
import { createNamespace, formatElevation } from "../utils/components.mjs";
import { useButtonGroup } from "./provide.mjs";
import { isArray, call } from "@varlet/shared";
const { name, n, classes } = createNamespace("button");
import { resolveComponent as _resolveComponent, normalizeClass as _normalizeClass, openBlock as _openBlock, createBlock as _createBlock, createCommentVNode as _createCommentVNode, renderSlot as _renderSlot, createElementVNode as _createElementVNode, createVNode as _createVNode, normalizeStyle as _normalizeStyle, resolveDirective as _resolveDirective, createElementBlock as _createElementBlock, withDirectives as _withDirectives, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";
const _withScopeId = (n2) => (_pushScopeId(""), n2 = n2(), _popScopeId(), n2);
const _hoisted_1 = ["type", "disabled"];
function __render__(_ctx, _cache) {
  const _component_var_loading = _resolveComponent("var-loading");
  const _component_var_hover_overlay = _resolveComponent("var-hover-overlay");
  const _directive_ripple = _resolveDirective("ripple");
  const _directive_hover = _resolveDirective("hover");
  return _withDirectives((_openBlock(), _createElementBlock("button", {
    class: _normalizeClass(
      _ctx.classes(
        _ctx.n(),
        _ctx.n("$--box"),
        _ctx.n(`--${_ctx.states.size}`),
        [_ctx.block, `${_ctx.n("$--flex")} ${_ctx.n("--block")}`, _ctx.n("$--inline-flex")],
        [_ctx.disabled, _ctx.n("--disabled")],
        [_ctx.states.text, `${_ctx.n(`--text-${_ctx.states.type}`)} ${_ctx.n("--text")}`, `${_ctx.n(`--${_ctx.states.type}`)} ${_ctx.states.elevation}`],
        [_ctx.states.text && _ctx.disabled, _ctx.n("--text-disabled")],
        [_ctx.round, _ctx.n("--round")],
        [_ctx.states.outline, _ctx.n("--outline")],
        [_ctx.loading || _ctx.pending, _ctx.n("--loading")]
      )
    ),
    style: _normalizeStyle({
      color: _ctx.states.textColor,
      background: _ctx.states.color
    }),
    type: _ctx.nativeType,
    disabled: _ctx.disabled,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onTouchstart: _cache[1] || (_cache[1] = (...args) => _ctx.handleTouchstart && _ctx.handleTouchstart(...args))
  }, [
    _ctx.loading || _ctx.pending ? (_openBlock(), _createBlock(_component_var_loading, {
      key: 0,
      class: _normalizeClass(_ctx.n("loading")),
      "var-button-cover": "",
      color: _ctx.loadingColor,
      type: _ctx.loadingType,
      size: _ctx.loadingSize,
      radius: _ctx.loadingRadius
    }, null, 8, ["class", "color", "type", "size", "radius"])) : _createCommentVNode("v-if", true),
    _createElementVNode(
      "div",
      {
        class: _normalizeClass(_ctx.classes(_ctx.n("content"), [_ctx.loading || _ctx.pending, _ctx.n("--hidden")]))
      },
      [
        _renderSlot(_ctx.$slots, "default")
      ],
      2
      /* CLASS */
    ),
    _createVNode(_component_var_hover_overlay, {
      hovering: _ctx.disabled || _ctx.loading || _ctx.pending ? false : _ctx.hovering
    }, null, 8, ["hovering"])
  ], 46, _hoisted_1)), [
    [_directive_ripple, { disabled: _ctx.disabled || !_ctx.ripple || _ctx.loading || _ctx.pending }],
    [_directive_hover, _ctx.handleHovering, "desktop"]
  ]);
}
const __sfc__ = defineComponent({
  name,
  components: {
    VarLoading,
    VarHoverOverlay
  },
  directives: { Ripple, Hover },
  props,
  setup(props2) {
    const pending = ref(false);
    const { buttonGroup } = useButtonGroup();
    const { hovering, handleHovering } = useHoverOverlay();
    const states = computed(() => {
      if (!buttonGroup) {
        return {
          elevation: formatElevation(props2.elevation, 2),
          type: props2.type != null ? props2.type : "default",
          size: props2.size != null ? props2.size : "normal",
          color: props2.color,
          text: props2.text,
          textColor: props2.textColor,
          outline: props2.outline
        };
      }
      const { type, size, color, textColor, mode } = buttonGroup;
      return {
        elevation: "",
        type: props2.type != null ? props2.type : type.value,
        size: props2.size != null ? props2.size : size.value,
        color: props2.color != null ? props2.color : color.value,
        textColor: props2.textColor != null ? props2.textColor : textColor.value,
        text: mode.value !== "normal",
        outline: mode.value === "outline"
      };
    });
    function attemptAutoLoading(result) {
      if (props2.autoLoading) {
        pending.value = true;
        result = isArray(result) ? result : [result];
        Promise.all(result).then(() => {
          pending.value = false;
        }).catch(() => {
          pending.value = false;
        });
      }
    }
    function handleClick(e) {
      const { loading, disabled, onClick } = props2;
      if (!onClick || loading || disabled || pending.value) {
        return;
      }
      attemptAutoLoading(call(onClick, e));
    }
    function handleTouchstart(e) {
      const { loading, disabled, onTouchstart } = props2;
      if (!onTouchstart || loading || disabled || pending.value) {
        return;
      }
      attemptAutoLoading(call(onTouchstart, e));
    }
    return {
      pending,
      states,
      hovering,
      n,
      classes,
      handleHovering,
      handleClick,
      handleTouchstart
    };
  }
});
__sfc__.render = __render__;
var stdin_default = __sfc__;
export {
  stdin_default as default
};
